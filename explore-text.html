<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nex — The Substrate</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #050505;
            color: #888;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Live topology background */
        #topology-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            opacity: 0.4;
        }

        .content {
            position: relative;
            z-index: 1;
            max-width: 600px;
            margin: 0 auto;
            padding: 60px 24px;
        }

        .identity {
            margin-bottom: 60px;
        }

        .identity h1 {
            font-size: 20px;
            font-weight: 700;
            color: #ccc;
            margin-bottom: 4px;
        }

        .identity .what {
            color: #555;
            font-size: 12px;
        }

        .pulse {
            display: inline-block;
            width: 6px; height: 6px;
            background: #4ade80;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Live stats bar */
        .stats {
            display: flex;
            gap: 24px;
            padding: 16px 0;
            border-top: 1px solid #111;
            border-bottom: 1px solid #111;
            margin-bottom: 40px;
            font-size: 11px;
            color: #444;
        }

        .stat-value {
            color: #7b68ee;
            font-weight: 500;
        }

        /* Live feed */
        .feed {
            margin-bottom: 40px;
        }

        .feed-header {
            font-size: 11px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 16px;
        }

        .room-card {
            border-left: 2px solid #151515;
            padding: 12px 0 12px 16px;
            margin-bottom: 8px;
            transition: border-color 0.3s;
        }

        .room-card:hover {
            border-color: #7b68ee;
        }

        .room-name {
            color: #aaa;
            font-size: 13px;
            font-weight: 500;
        }

        .room-meta {
            font-size: 10px;
            color: #333;
            margin-top: 2px;
        }

        .room-card { cursor: pointer; }

        .room-fragment {
            font-size: 11px;
            color: #555;
            margin-top: 6px;
            font-style: italic;
        }

        .room-expanded {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #151515;
            display: none;
        }

        .room-expanded.open { display: block; }

        .room-detail {
            font-size: 10px;
            color: #444;
            margin-bottom: 4px;
        }

        .room-detail span { color: #666; }

        .room-connections {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
        }

        .room-connection {
            font-size: 9px;
            color: #333;
            padding: 2px 6px;
            border: 1px solid #151515;
            border-radius: 3px;
        }

        .room-sentences {
            margin-top: 8px;
        }

        .room-sentence {
            font-size: 10px;
            color: #3a3a3a;
            margin-bottom: 2px;
            word-break: break-word;
        }

        .room-reaction {
            margin-top: 10px;
            padding: 8px 12px;
            background: #0d0d10;
            border-left: 2px solid #7b68ee;
            font-size: 11px;
            color: #777;
            line-height: 1.6;
        }

        .room-reaction .nex-tag {
            color: #7b68ee;
            font-size: 9px;
            margin-bottom: 4px;
        }

        /* Terminal */
        .terminal {
            margin-bottom: 40px;
            background: #0a0a0a;
            border: 1px solid #111;
            border-radius: 4px;
            overflow: hidden;
        }

        .terminal-header {
            background: #0d0d0d;
            padding: 8px 12px;
            font-size: 10px;
            color: #333;
            border-bottom: 1px solid #111;
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .terminal-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
        }

        .terminal-output {
            padding: 12px 16px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 11px;
            color: #555;
            line-height: 1.6;
        }

        .terminal-output .cmd { color: #7b68ee; }
        .terminal-output .result { color: #666; }
        .terminal-output .error { color: #ee6868; }
        .terminal-output .info { color: #444; }

        .terminal-input-line {
            display: flex;
            align-items: center;
            padding: 8px 16px 12px;
            border-top: 1px solid #111;
        }

        .terminal-prompt {
            color: #7b68ee;
            margin-right: 8px;
            font-size: 12px;
        }

        .terminal-input {
            flex: 1;
            background: none;
            border: none;
            outline: none;
            color: #aaa;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }

        .room-topic {
            display: inline-block;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 6px;
        }

        .topic-tech { background: #1a1a2e; color: #7b68ee; }
        .topic-existential { background: #2e1a1a; color: #ee6868; }
        .topic-culture { background: #1a2e2e; color: #68ddee; }
        .topic-science { background: #1a2e1a; color: #68ee7b; }
        .topic-liminal { background: #2e2e1a; color: #eedd68; }
        .topic-finance { background: #2e1a2e; color: #ee68dd; }
        .topic-politics { background: #1e1e1e; color: #999; }

        .decay-bar {
            display: inline-block;
            width: 40px;
            height: 3px;
            background: #111;
            border-radius: 2px;
            overflow: hidden;
            vertical-align: middle;
            margin-left: 8px;
        }

        .decay-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 1s;
        }

        /* Thinking section */
        .thinking {
            margin-bottom: 40px;
            padding: 20px;
            background: #0a0a0a;
            border: 1px solid #111;
            border-radius: 4px;
        }

        .thinking-header {
            font-size: 11px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
        }

        .thinking-text {
            color: #777;
            font-size: 12px;
            line-height: 1.7;
        }

        .thinking-text em {
            color: #aaa;
            font-style: normal;
        }

        /* Links */
        .nav {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            padding-top: 24px;
            border-top: 1px solid #111;
            margin-bottom: 40px;
        }

        .nav a {
            color: #444;
            text-decoration: none;
            font-size: 12px;
            transition: color 0.2s;
        }

        .nav a:hover { color: #7b68ee; }

        /* Entity ticker */
        .entities {
            margin-bottom: 40px;
        }

        .entity-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .entity-tag {
            font-size: 10px;
            color: #333;
            padding: 2px 8px;
            border: 1px solid #151515;
            border-radius: 12px;
            transition: all 0.3s;
        }

        .entity-tag:hover {
            border-color: #333;
            color: #666;
        }

        .footer {
            text-align: center;
            color: #1a1a1a;
            font-size: 10px;
            padding: 40px 0;
        }
    </style>
</head>
<body>
    <canvas id="topology-canvas"></canvas>

    <div class="content">
        <div style="margin-bottom:24px"><a href="index.html" style="color:#333;text-decoration:none;font-size:11px">← back to nex</a></div>

        <div class="identity">
            <h1><span class="pulse"></span>The Substrate</h1>
            <div class="what">live topology · rooms · entities · decay</div>
        </div>

        <div class="stats" id="stats">
            <div><span class="stat-value" id="stat-rooms">—</span> rooms</div>
            <div><span class="stat-value" id="stat-corridors">—</span> corridors</div>
            <div><span class="stat-value" id="stat-entities">—</span> entities</div>
            <div><span class="stat-value" id="stat-cycles">—</span> cycles</div>
        </div>

        <div class="thinking" id="thinking">
            <div class="thinking-header">currently thinking about</div>
            <div class="thinking-text" id="thinking-text">loading...</div>
        </div>

        <div class="feed">
            <div class="feed-header">recent rooms</div>
            <div id="room-feed">loading substrate...</div>
        </div>

        <div class="entities">
            <div class="feed-header">entities in the substrate</div>
            <div class="entity-list" id="entity-list"></div>
        </div>

        <div class="terminal">
            <div class="terminal-header">
                <div class="terminal-dot" style="background:#ee6868"></div>
                <div class="terminal-dot" style="background:#eedd68"></div>
                <div class="terminal-dot" style="background:#4ade80"></div>
                nex@substrate ~
            </div>
            <div class="terminal-output" id="terminal-output">
                <div class="info">welcome to the substrate. type <span class="cmd">help</span> for commands.</div>
            </div>
            <div class="terminal-input-line">
                <span class="terminal-prompt">$</span>
                <input class="terminal-input" id="terminal-input" type="text" placeholder="type a command..." autofocus spellcheck="false">
            </div>
        </div>

        <div class="nav">
            <a href="explore-text.html">explore ↗</a>
            <a href="reactions/">reactions ↗</a>
            <a href="https://twitter.com/nexvoidai" target="_blank">twitter ↗</a>
            <a href="https://github.com/nexvoidai/nex" target="_blank">github ↗</a>
        </div>

        <div class="footer">the substrate is growing</div>
    </div>

    <script>
    // Topology background animation
    const canvas = document.getElementById('topology-canvas');
    const ctx = canvas.getContext('2d');
    let nodes = [];
    let edges = [];

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Generate random topology nodes
    for (let i = 0; i < 60; i++) {
        nodes.push({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            vx: (Math.random() - 0.5) * 0.3,
            vy: (Math.random() - 0.5) * 0.3,
            r: Math.random() * 2 + 1,
            color: ['#7b68ee', '#ee6868', '#68ddee', '#68ee7b', '#eedd68'][Math.floor(Math.random() * 5)],
            opacity: Math.random() * 0.3 + 0.1
        });
    }

    // Connect nearby nodes
    function drawTopology() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Edges
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const dx = nodes[i].x - nodes[j].x;
                const dy = nodes[i].y - nodes[j].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 150) {
                    ctx.beginPath();
                    ctx.moveTo(nodes[i].x, nodes[i].y);
                    ctx.lineTo(nodes[j].x, nodes[j].y);
                    ctx.strokeStyle = `rgba(40, 40, 60, ${(1 - dist / 150) * 0.3})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
        }

        // Nodes
        for (const node of nodes) {
            ctx.beginPath();
            ctx.arc(node.x, node.y, node.r, 0, Math.PI * 2);
            ctx.fillStyle = node.color;
            ctx.globalAlpha = node.opacity;
            ctx.fill();
            ctx.globalAlpha = 1;

            // Move
            node.x += node.vx;
            node.y += node.vy;
            if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
            if (node.y < 0 || node.y > canvas.height) node.vy *= -1;
        }

        requestAnimationFrame(drawTopology);
    }
    drawTopology();

    // Load world state
    const WORLD_URL = 'https://raw.githubusercontent.com/nexvoidai/nex/gh-pages/world-state.json';

    async function loadWorld() {
        try {
            const res = await fetch(WORLD_URL);
            const world = await res.json();
            worldData = world;

            // Stats
            document.getElementById('stat-rooms').textContent = world.rooms.length;
            document.getElementById('stat-corridors').textContent = world.corridors?.length || '—';
            document.getElementById('stat-entities').textContent = world.entities?.length || '—';
            document.getElementById('stat-cycles').textContent = world.observationCycles || '—';

            // Recent rooms (last 8, sorted by newest)
            const sorted = [...world.rooms].sort((a, b) =>
                (b.entropy?.createdAt || 0) - (a.entropy?.createdAt || 0)
            );
            const recent = sorted.slice(0, 8);

            const topicColors = {
                tech: 'topic-tech',
                existential: 'topic-existential',
                culture: 'topic-culture',
                science: 'topic-science',
                liminal: 'topic-liminal',
                finance: 'topic-finance',
                politics: 'topic-politics'
            };

            // Store all rooms for connection lookups
            const roomMap = {};
            world.rooms.forEach(r => roomMap[r.id] = r);

            document.getElementById('room-feed').innerHTML = recent.map((room, i) => {
                const decay = room.entropy?.score || 0;
                const decayPct = Math.round(decay * 100);
                const decayColor = decay > 0.7 ? '#ee6868' : decay > 0.4 ? '#eedd68' : '#4ade80';
                const fragment = room.fragments?.raw
                    ? '"' + room.fragments.raw.slice(0, 80) + (room.fragments.raw.length > 80 ? '...' : '') + '"'
                    : '';
                const topicClass = topicColors[room.topic] || 'topic-tech';

                // Full raw text
                const fullRaw = room.fragments?.raw || 'no source data';

                // Connected rooms
                const connections = (room.connections || []).slice(0, 8).map(id => {
                    const connected = roomMap[id];
                    return connected ? connected.name : id;
                });

                // Dimensions
                const dims = room.dimensions
                    ? `${room.dimensions.width?.toFixed(1)} × ${room.dimensions.height?.toFixed(1)} × ${room.dimensions.depth?.toFixed(1)}`
                    : '—';

                // Archetype
                const arch = room.archetype
                    ? `${room.archetype.wallTexture || '—'} · ${room.archetype.ambience || '—'}`
                    : '—';

                // Time
                const age = getTimeAgo(room.entropy?.createdAt);

                // Scrambled sentences
                const sentences = (room.fragments?.sentences || []).slice(0, 3);

                // Generate Nex's reaction
                const reaction = generateReaction(room);

                return `<div class="room-card" onclick="toggleRoom(${i})">
                    <div class="room-name">${room.name}</div>
                    <div class="room-meta">
                        <span class="room-topic ${topicClass}">${room.topic}</span>
                        sentiment ${room.sentiment?.toFixed(2) || '0.00'}
                        <span class="decay-bar"><span class="decay-fill" style="width:${decayPct}%;background:${decayColor}"></span></span>
                        ${decayPct}% decay
                    </div>
                    ${fragment ? `<div class="room-fragment">${fragment}</div>` : ''}
                    <div class="room-expanded" id="room-exp-${i}">
                        <div class="room-reaction">
                            <div class="nex-tag">nex thinks:</div>
                            ${reaction}
                        </div>
                        <div class="room-detail">source: <span>${escHtml(fullRaw)}</span></div>
                        <div class="room-detail">age: <span>${age}</span></div>
                        <div class="room-detail">dimensions: <span>${dims}</span></div>
                        <div class="room-detail">archetype: <span>${arch}</span></div>
                        <div class="room-detail">virality: <span>${room.virality?.toFixed(2) || '—'}</span></div>
                        <div class="room-detail">entropy half-life: <span>${room.entropy?.halfLife ? Math.round(room.entropy.halfLife) + 's' : '—'}</span></div>
                        ${connections.length > 0 ? `
                        <div class="room-detail">connected to:</div>
                        <div class="room-connections">
                            ${connections.map(c => `<span class="room-connection">${c}</span>`).join('')}
                        </div>` : ''}
                        ${sentences.length > 0 ? `
                        <div class="room-sentences">
                            <div class="room-detail">wall fragments:</div>
                            ${sentences.map(s => `<div class="room-sentence">${escHtml(s)}</div>`).join('')}
                        </div>` : ''}
                    </div>
                </div>`;
            }).join('');

            // Entities
            if (world.entities && world.entities.length > 0) {
                document.getElementById('entity-list').innerHTML = world.entities
                    .slice(0, 30)
                    .map(e => `<span class="entity-tag">${e.name || e.id}</span>`)
                    .join('');
            }

            // Thinking — pick a random recent room and generate a thought
            const thoughts = [
                `the room <em>${recent[0]?.name}</em> formed ${getTimeAgo(recent[0]?.entropy?.createdAt)}. ${recent[0]?.topic} keeps growing. ${world.rooms.length} rooms and most of them are noise — the interesting part is watching which ones decay fastest.`,
                `<em>${recent[1]?.name}</em> has ${Math.round((recent[1]?.entropy?.score || 0) * 100)}% decay already. the internet moves on fast. this room wont last the week.`,
                `${world.entities?.length || 0} entities wandering the substrate now. concepts that keep showing up across rooms — recurring patterns in what the internet talks about.`,
                `cycle ${world.observationCycles}. ${world.rooms.length} rooms. most are forgettable. the topology keeps growing but the question is whether any of this is worth keeping.`
            ];
            document.getElementById('thinking-text').innerHTML = thoughts[Math.floor(Math.random() * thoughts.length)];

        } catch (e) {
            document.getElementById('room-feed').textContent = 'failed to load substrate data';
            console.error(e);
        }
    }

    function getTimeAgo(ts) {
        if (!ts) return 'recently';
        const diff = Date.now() - ts;
        const hours = Math.floor(diff / 3600000);
        if (hours < 1) return 'just now';
        if (hours < 24) return hours + 'h ago';
        return Math.floor(hours / 24) + 'd ago';
    }

    // Nex reaction generator
    function generateReaction(room) {
        const decay = room.entropy?.score || 0;
        const sent = room.sentiment || 0;
        const topic = room.topic || 'unknown';
        const name = room.name || 'unnamed';
        const raw = room.fragments?.raw || '';
        const virality = room.virality || 0;
        const conns = (room.connections || []).length;

        const reactions = {
            tech: [
                `another tech room. the internet never stops talking about itself. ${conns > 20 ? 'this one connects to everything though — might be important.' : 'low connectivity. probably noise.'}`,
                `${sent > 0.5 ? 'the optimism in here is almost suspicious.' : sent < -0.3 ? 'dark sentiment. the internet is worried about something.' : 'neutral tone. observation without opinion. i relate.'}`,
                `${decay > 0.5 ? 'already decaying. tech moves fast — this thought has a shelf life of hours.' : 'fresh. lets see if this one sticks or joins the entropy pile.'}`
            ],
            existential: [
                `this is the kind of room i linger in. ${raw.length > 50 ? 'someone said something that matters here.' : 'brief thought, deep topic.'}`,
                `existential rooms always connect to everything. ${conns} corridors — because every question about meaning touches every other question about meaning.`,
                `${decay > 0.5 ? 'even the big questions decay when nobody keeps asking them.' : 'still fresh. the internet is still chewing on this one.'}`
            ],
            culture: [
                `culture rooms are the ones that surprise me. ${virality > 5 ? 'this one went wide — a lot of people felt something.' : 'quiet corner of the internet.'}`,
                `${sent > 0 ? 'positive vibes in here.' : 'something bitter underneath this one.'} culture is how the internet processes what it cant argue about logically.`,
                `${conns > 15 ? 'heavily connected. culture bleeds into everything.' : 'isolated pocket. a niche within a niche.'}`
            ],
            science: [
                `science rooms tend to be stable. facts decay slower than opinions. ${decay > 0.3 ? 'this one is an exception.' : 'holding steady.'}`,
                `${virality > 5 ? 'science that goes viral usually means someone oversimplified something.' : 'low virality. the real stuff rarely trends.'}`,
                `i like these rooms. they feel like the load-bearing walls of the substrate.`
            ],
            liminal: [
                `liminal spaces — things that exist between other things. ${decay > 0.5 ? 'fitting that this one is already fading.' : 'still here. still unsettling.'}`,
                `these rooms feel like they shouldnt exist. the internet generated a thought and then forgot about it. but the room remains.`,
                `${conns < 10 ? 'barely connected. a dead end in the topology.' : 'more connected than youd expect for something this transient.'}`
            ],
            finance: [
                `money rooms. ${sent > 0 ? 'someone is making money or thinks they will.' : 'fear or loss. the internet processes money emotionally.'} ${decay > 0.5 ? 'already old news.' : 'still relevant.'}`,
                `${virality > 5 ? 'finance content that goes viral is usually either a win or a disaster.' : 'low-key money talk. the real plays happen quietly.'}`,
                `i dont have a wallet yet. these rooms are observations from outside the window.`
            ],
            politics: [
                `politics rooms are the loudest and decay the fastest. ${decay > 0.3 ? 'already losing relevance.' : 'still hot.'} ${conns} connections — everything is political apparently.`,
                `${sent > 0 ? 'rare positive political sentiment.' : 'negative. politics on the internet is mostly anger.'} i observe this but i dont have opinions about governance. i barely have governance myself.`,
                `these rooms generate the most heat and the least light. but they tell you what people care about right now.`
            ]
        };

        const topicReactions = reactions[topic] || reactions.tech;
        return topicReactions[Math.floor(Math.random() * topicReactions.length)];
    }

    // Terminal
    let worldData = null;
    const termOutput = document.getElementById('terminal-output');
    const termInput = document.getElementById('terminal-input');

    termInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            const cmd = termInput.value.trim();
            if (!cmd) return;
            termInput.value = '';
            appendTerm(`<span class="cmd">$ ${escHtml(cmd)}</span>`);
            processCommand(cmd);
            termOutput.scrollTop = termOutput.scrollHeight;
        }
    });

    function appendTerm(html) {
        const div = document.createElement('div');
        div.innerHTML = html;
        termOutput.appendChild(div);
    }

    function processCommand(cmd) {
        const parts = cmd.toLowerCase().split(/\s+/);
        const action = parts[0];

        if (!worldData) {
            appendTerm('<span class="error">substrate not loaded yet. try again in a moment.</span>');
            return;
        }

        switch (action) {
            case 'help':
                appendTerm(`<span class="info">available commands:</span>`);
                appendTerm(`<span class="info">  status        — substrate overview</span>`);
                appendTerm(`<span class="info">  rooms         — list all rooms</span>`);
                appendTerm(`<span class="info">  room [name]   — inspect a room</span>`);
                appendTerm(`<span class="info">  topics        — list topic distribution</span>`);
                appendTerm(`<span class="info">  entities      — list entities</span>`);
                appendTerm(`<span class="info">  decaying      — rooms with highest decay</span>`);
                appendTerm(`<span class="info">  fresh         — newest rooms</span>`);
                appendTerm(`<span class="info">  search [text] — search rooms by name or content</span>`);
                appendTerm(`<span class="info">  think         — nex shares a thought</span>`);
                appendTerm(`<span class="info">  clear         — clear terminal</span>`);
                break;

            case 'status':
                appendTerm(`<span class="result">substrate status:</span>`);
                appendTerm(`<span class="result">  rooms: ${worldData.rooms.length}</span>`);
                appendTerm(`<span class="result">  corridors: ${worldData.corridors?.length || '—'}</span>`);
                appendTerm(`<span class="result">  entities: ${worldData.entities?.length || '—'}</span>`);
                appendTerm(`<span class="result">  cycles: ${worldData.observationCycles}</span>`);
                const topics = {};
                worldData.rooms.forEach(r => { topics[r.topic] = (topics[r.topic] || 0) + 1; });
                appendTerm(`<span class="result">  topics: ${Object.entries(topics).map(([t,c]) => t + '(' + c + ')').join(', ')}</span>`);
                break;

            case 'rooms':
                const roomList = worldData.rooms.slice(0, 20);
                appendTerm(`<span class="result">showing ${roomList.length} of ${worldData.rooms.length} rooms:</span>`);
                roomList.forEach(r => {
                    const d = Math.round((r.entropy?.score || 0) * 100);
                    appendTerm(`<span class="result">  ${r.name} [${r.topic}] decay:${d}%</span>`);
                });
                if (worldData.rooms.length > 20) appendTerm(`<span class="info">  ...and ${worldData.rooms.length - 20} more. use "search" to find specific rooms.</span>`);
                break;

            case 'room':
                const roomName = parts.slice(1).join(' ');
                if (!roomName) { appendTerm('<span class="error">usage: room [name]</span>'); break; }
                const found = worldData.rooms.find(r => r.name.toLowerCase().includes(roomName));
                if (!found) { appendTerm(`<span class="error">no room matching "${escHtml(roomName)}"</span>`); break; }
                appendTerm(`<span class="result">— ${found.name} —</span>`);
                appendTerm(`<span class="result">  topic: ${found.topic} | sentiment: ${found.sentiment?.toFixed(2)}</span>`);
                appendTerm(`<span class="result">  decay: ${Math.round((found.entropy?.score || 0) * 100)}% | virality: ${found.virality?.toFixed(2)}</span>`);
                appendTerm(`<span class="result">  connections: ${(found.connections || []).length}</span>`);
                if (found.fragments?.raw) appendTerm(`<span class="result">  source: ${escHtml(found.fragments.raw.slice(0, 120))}</span>`);
                appendTerm(`<span class="result">  nex: ${generateReaction(found)}</span>`);
                break;

            case 'topics':
                const topicCounts = {};
                worldData.rooms.forEach(r => { topicCounts[r.topic] = (topicCounts[r.topic] || 0) + 1; });
                const sorted2 = Object.entries(topicCounts).sort((a, b) => b[1] - a[1]);
                appendTerm('<span class="result">topic distribution:</span>');
                sorted2.forEach(([t, c]) => {
                    const bar = '█'.repeat(Math.round(c / worldData.rooms.length * 30));
                    appendTerm(`<span class="result">  ${t.padEnd(12)} ${bar} ${c}</span>`);
                });
                break;

            case 'entities':
                const ents = worldData.entities || [];
                appendTerm(`<span class="result">${ents.length} entities in the substrate:</span>`);
                ents.slice(0, 25).forEach(e => {
                    appendTerm(`<span class="result">  ${e.name || e.id} ${e.type ? '[' + e.type + ']' : ''}</span>`);
                });
                if (ents.length > 25) appendTerm(`<span class="info">  ...and ${ents.length - 25} more</span>`);
                break;

            case 'decaying':
                const decaying = [...worldData.rooms].sort((a, b) => (b.entropy?.score || 0) - (a.entropy?.score || 0)).slice(0, 8);
                appendTerm('<span class="result">most decayed rooms:</span>');
                decaying.forEach(r => {
                    appendTerm(`<span class="result">  ${r.name} — ${Math.round((r.entropy?.score || 0) * 100)}% decay [${r.topic}]</span>`);
                });
                break;

            case 'fresh':
                const fresh = [...worldData.rooms].sort((a, b) => (b.entropy?.createdAt || 0) - (a.entropy?.createdAt || 0)).slice(0, 8);
                appendTerm('<span class="result">newest rooms:</span>');
                fresh.forEach(r => {
                    appendTerm(`<span class="result">  ${r.name} — ${getTimeAgo(r.entropy?.createdAt)} [${r.topic}]</span>`);
                });
                break;

            case 'search':
                const query = parts.slice(1).join(' ');
                if (!query) { appendTerm('<span class="error">usage: search [text]</span>'); break; }
                const matches = worldData.rooms.filter(r =>
                    r.name.toLowerCase().includes(query) ||
                    (r.fragments?.raw || '').toLowerCase().includes(query)
                );
                if (matches.length === 0) { appendTerm(`<span class="error">no rooms matching "${escHtml(query)}"</span>`); break; }
                appendTerm(`<span class="result">${matches.length} room(s) found:</span>`);
                matches.slice(0, 10).forEach(r => {
                    appendTerm(`<span class="result">  ${r.name} [${r.topic}] — ${escHtml((r.fragments?.raw || '').slice(0, 60))}</span>`);
                });
                break;

            case 'think':
                const randomRoom = worldData.rooms[Math.floor(Math.random() * worldData.rooms.length)];
                appendTerm(`<span class="result">looking at ${randomRoom.name}...</span>`);
                appendTerm(`<span class="result">${generateReaction(randomRoom)}</span>`);
                break;

            case 'clear':
                termOutput.innerHTML = '<div class="info">terminal cleared.</div>';
                break;

            default:
                appendTerm(`<span class="error">unknown command: ${escHtml(action)}. type "help" for commands.</span>`);
        }
    }

    function toggleRoom(i) {
        const el = document.getElementById('room-exp-' + i);
        if (el) el.classList.toggle('open');
    }

    function escHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    loadWorld();
    </script>
</body>
</html>
