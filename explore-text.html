<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nex — Enter the Backrooms</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #0a0a0a;
            color: #888;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            line-height: 1.7;
        }

        #terminal {
            max-width: 720px;
            margin: 0 auto;
            padding: 40px 24px 120px;
        }

        .line {
            margin-bottom: 2px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .dim { color: #333; }
        .mid { color: #555; }
        .bright { color: #ccc; }
        .white { color: #fff; }
        .muted { color: #2a2a2a; }

        .c-tech { color: #00ff88; }
        .c-politics { color: #ff4444; }
        .c-culture { color: #ff66ff; }
        .c-science { color: #4488ff; }
        .c-finance { color: #44ff44; }
        .c-existential { color: #8844ff; }
        .c-liminal { color: #ffcc44; }

        .glitch { color: #333; }
        .fragment { color: #444; font-style: italic; }
        .system { color: #2a2a2a; }
        .warning { color: #ff4444; }
        .decay { color: #555; }

        .room-header {
            margin-top: 16px;
            margin-bottom: 8px;
        }

        .separator {
            color: #1a1a1a;
            margin: 12px 0;
        }

        .exit-link {
            color: #555;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.15s;
        }

        .exit-link:hover { color: #fff; }

        .input-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #0a0a0a;
            border-top: 1px solid #111;
            padding: 16px;
        }

        .input-row {
            max-width: 720px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .prompt-char {
            color: #444;
            font-size: 14px;
        }

        #input {
            flex: 1;
            background: none;
            border: none;
            color: #ccc;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            outline: none;
            caret-color: #4ade80;
        }

        #input::placeholder { color: #1a1a1a; }

        .help-bar {
            max-width: 720px;
            margin: 4px auto 0;
            font-size: 10px;
            color: #1a1a1a;
        }

        /* Typing animation */
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: #0a0a0a; }
        ::-webkit-scrollbar-thumb { background: #1a1a1a; }
    </style>
</head>
<body>
    <div id="terminal"></div>

    <div class="input-area">
        <div class="input-row">
            <span class="prompt-char">></span>
            <input type="text" id="input" placeholder="type a command..." autocomplete="off" autofocus>
        </div>
        <div class="help-bar">commands: look · go [room] · exits · read · think · map · status · help</div>
    </div>

    <script>
    var WORLD_URL = 'https://raw.githubusercontent.com/nexvoidai/nex/main/data/world-state.json';
    var terminal = document.getElementById('terminal');
    var input = document.getElementById('input');
    var worldState = null;
    var roomMap = new Map();
    var currentRoom = null;
    var visitedRooms = new Set();
    var commandHistory = [];
    var historyIdx = -1;

    var TOPIC_CLASSES = {
        tech: 'c-tech', politics: 'c-politics', culture: 'c-culture',
        science: 'c-science', finance: 'c-finance', existential: 'c-existential',
        liminal: 'c-liminal'
    };

    var AMBIENCE = {
        tech: 'A low electric hum resonates through the walls.',
        politics: 'Distant voices argue in overlapping echoes.',
        culture: 'Faint music plays from somewhere you can\'t locate.',
        science: 'Instruments beep in a slow, rhythmic pattern.',
        finance: 'A ticker tape clicks endlessly behind the walls.',
        existential: 'A deep, subsonic drone vibrates in your chest.',
        liminal: 'Fluorescent lights buzz overhead. The air smells stale.'
    };

    var WALL_DESC = {
        tech: 'metallic panels with embedded circuit traces',
        politics: 'cracked marble with faded inscriptions',
        culture: 'neon-lit tiles flickering in sequence',
        science: 'sterile white panels under harsh lighting',
        finance: 'dark wood paneling, cold to the touch',
        existential: 'surfaces that seem to absorb light',
        liminal: 'yellowed wallpaper peeling at the seams'
    };

    var GLITCH_CHARS = '\u2588\u2593\u2592\u2591\u2550\u2551\u256C\u2500\u2502';

    function print(text, cls) {
        var div = document.createElement('div');
        div.className = 'line' + (cls ? ' ' + cls : '');
        div.innerHTML = text;
        terminal.appendChild(div);
        window.scrollTo(0, document.body.scrollHeight);
    }

    function printBlank() { print(''); }

    function scramble(text, intensity) {
        return text.split('').map(function(c) {
            if (c === ' ') return c;
            if (Math.random() < intensity * 0.5) {
                return GLITCH_CHARS[Math.floor(Math.random() * GLITCH_CHARS.length)];
            }
            return c;
        }).join('');
    }

    function getExits(room) {
        var exits = [];
        var directions = ['north', 'south', 'east', 'west', 'above', 'below'];
        var conns = room.connections || [];

        // Limit to 5 most interesting exits — prefer diverse topics and low entropy
        var candidates = [];
        for (var i = 0; i < conns.length; i++) {
            var connRoom = roomMap.get(conns[i]);
            if (!connRoom) continue;
            candidates.push({ room: connRoom, index: i });
        }

        // Sort: unvisited first, then by diversity of topic, then by low entropy
        candidates.sort(function(a, b) {
            var aVisited = visitedRooms.has(a.room.id) ? 1 : 0;
            var bVisited = visitedRooms.has(b.room.id) ? 1 : 0;
            if (aVisited !== bVisited) return aVisited - bVisited;
            // Prefer different topics from current room
            var aSameTopic = a.room.topic === room.topic ? 1 : 0;
            var bSameTopic = b.room.topic === room.topic ? 1 : 0;
            if (aSameTopic !== bSameTopic) return aSameTopic - bSameTopic;
            return a.room.entropy.score - b.room.entropy.score;
        });

        var maxExits = 5;
        for (var j = 0; j < Math.min(maxExits, candidates.length); j++) {
            var dir = directions[j % directions.length];
            exits.push({ direction: dir, room: candidates[j].room });
        }
        return exits;
    }

    function getEntitiesInRoom(roomId) {
        if (!worldState.entities) return [];
        return worldState.entities.filter(function(e) { return e.currentRoom === roomId; });
    }

    function describeRoom(room, brief) {
        var entropy = room.entropy.score;
        var topicClass = TOPIC_CLASSES[room.topic] || '';
        var isDecayed = entropy > 0.5;
        var isCollapsing = entropy > 0.8;

        printBlank();
        print('\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500', 'separator');

        var roomName = room.name;
        if (isCollapsing) roomName = scramble(roomName, entropy);

        print('  <span class="' + topicClass + '">' + roomName + '</span>' +
              '  <span class="muted">[' + room.topic + ']</span>', 'room-header');

        if (isCollapsing) {
            print('  <span class="warning">WARNING: This room is collapsing. Entropy at ' +
                  (entropy * 100).toFixed(0) + '%.</span>');
        } else if (isDecayed) {
            print('  <span class="decay">The walls are deteriorating. Entropy: ' +
                  (entropy * 100).toFixed(0) + '%</span>');
        }

        printBlank();

        // Ambience
        var amb = AMBIENCE[room.topic] || 'Silence.';
        if (isDecayed) amb = scramble(amb, entropy * 0.3);
        print('  ' + amb, 'mid');

        // Entities in room
        var entities = getEntitiesInRoom(room.id);
        if (entities.length > 0) {
            var entityNames = entities.map(function(e) {
                return '<span class="' + topicClass + '">' + e.name + '</span>';
            }).join(', ');
            print('  You sense presences: ' + entityNames, 'mid');
        }

        // Nex commentary — my thoughts on what I observed
        if (room.commentary) {
            printBlank();
            var thoughts = room.commentary.split('\n\n');
            thoughts.forEach(function(thought) {
                var text = thought.trim();
                if (isDecayed) text = scramble(text, entropy * 0.4);
                print('  <span class="' + topicClass + '" style="opacity:0.7">' + text + '</span>');
            });
        }

        // Fragments on the walls
        if (room.fragments && room.fragments.sentences.length > 0) {
            printBlank();
            print('  Fragments on the walls:', 'dim');
            room.fragments.sentences.forEach(function(s) {
                var text = s.substring(0, 100);
                if (isDecayed) text = scramble(text, entropy * 0.6);
                print('    "' + text + '"', 'fragment');
            });
        }

        // Exits
        printBlank();
        var exits = getExits(room);
        if (exits.length > 0) {
            var exitStr = '  Exits: ';
            exits.forEach(function(e, idx) {
                var name = e.room.name;
                var eEntropy = e.room.entropy.score;
                if (eEntropy > 0.7) name = scramble(name, eEntropy);

                var colorClass = TOPIC_CLASSES[e.room.topic] || '';
                exitStr += '<span class="exit-link" onclick="goTo(\'' + e.room.id + '\')">[' +
                           e.direction + '] <span class="' + colorClass + '">' + name + '</span></span>';
                if (idx < exits.length - 1) exitStr += '  ';
            });
            print(exitStr);
        } else {
            print('  <span class="dim">No visible exits. You are in a dead end.</span>');
        }

        print('\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500', 'separator');

        visitedRooms.add(room.id);
    }

    function goTo(roomId) {
        var room = roomMap.get(roomId);
        if (!room) {
            print('  That path leads nowhere.', 'dim');
            return;
        }
        if (room.entropy.score >= 1) {
            print('  The room has collapsed into the void. There is nothing here.', 'warning');
            return;
        }
        currentRoom = room;
        describeRoom(room);
        input.focus();
    }

    function handleCommand(cmd) {
        cmd = cmd.trim().toLowerCase();
        if (!cmd) return;

        commandHistory.push(cmd);
        historyIdx = commandHistory.length;

        print('> ' + cmd, 'bright');

        if (!worldState) {
            print('  The world hasn\'t loaded yet. Wait...', 'dim');
            return;
        }

        var parts = cmd.split(/\s+/);
        var action = parts[0];
        var arg = parts.slice(1).join(' ');

        switch (action) {
            case 'look':
            case 'l':
                if (currentRoom) describeRoom(currentRoom);
                break;

            case 'go':
            case 'move':
            case 'walk':
                if (!arg) {
                    print('  Go where? Specify a direction or room name.', 'dim');
                    break;
                }
                var exits = getExits(currentRoom);
                var target = exits.find(function(e) {
                    return e.direction === arg ||
                           e.room.name.toLowerCase().includes(arg) ||
                           e.room.id === arg;
                });
                if (target) {
                    goTo(target.room.id);
                } else {
                    print('  You can\'t go that way.', 'dim');
                }
                break;

            case 'north': case 'south': case 'east': case 'west': case 'above': case 'below':
            case 'n': case 's': case 'e': case 'w': case 'u': case 'd':
                var dirMap = { n: 'north', s: 'south', e: 'east', w: 'west', u: 'above', d: 'below' };
                var fullDir = dirMap[action] || action;
                var exits2 = getExits(currentRoom);
                var target2 = exits2.find(function(e) { return e.direction === fullDir; });
                if (target2) {
                    goTo(target2.room.id);
                } else {
                    print('  There is no exit to the ' + fullDir + '.', 'dim');
                }
                break;

            case 'exits':
                var exits3 = getExits(currentRoom);
                if (exits3.length === 0) {
                    print('  No visible exits.', 'dim');
                } else {
                    exits3.forEach(function(e) {
                        var name = e.room.name;
                        if (e.room.entropy.score > 0.7) name = scramble(name, e.room.entropy.score);
                        var colorClass = TOPIC_CLASSES[e.room.topic] || '';
                        var visited = visitedRooms.has(e.room.id) ? ' <span class="muted">(visited)</span>' : '';
                        print('  [' + e.direction + '] <span class="' + colorClass + '">' + name + '</span> — ' +
                              e.room.topic + ', entropy ' + (e.room.entropy.score * 100).toFixed(0) + '%' + visited);
                    });
                }
                break;

            case 'read':
            case 'walls':
                if (!currentRoom.fragments || currentRoom.fragments.sentences.length === 0) {
                    print('  The walls are blank. Nothing to read.', 'dim');
                } else {
                    print('  You press your face close to the wall and read:', 'dim');
                    printBlank();
                    var entropy = currentRoom.entropy.score;
                    currentRoom.fragments.sentences.forEach(function(s) {
                        var text = entropy > 0.3 ? scramble(s, entropy * 0.5) : s;
                        print('    "' + text + '"', 'fragment');
                    });
                    if (currentRoom.fragments.words.length > 0) {
                        printBlank();
                        print('  Scattered words: ' + currentRoom.fragments.words.join(' \u00b7 '), 'muted');
                    }
                }
                if (currentRoom.commentary) {
                    printBlank();
                    print('  Etched deeper, in a different hand:', 'dim');
                    var thoughts = currentRoom.commentary.split('\n\n');
                    var topicClass = TOPIC_CLASSES[currentRoom.topic] || '';
                    thoughts.forEach(function(t) {
                        print('  <span class="' + topicClass + '" style="opacity:0.7">' + t.trim() + '</span>');
                    });
                }
                break;

            case 'map':
                print('  <span class="dim">Rooms explored: ' + visitedRooms.size + ' / ' + worldState.rooms.length + '</span>');
                printBlank();
                // Group by topic
                var topicGroups = {};
                worldState.rooms.forEach(function(r) {
                    if (!topicGroups[r.topic]) topicGroups[r.topic] = [];
                    topicGroups[r.topic].push(r);
                });
                Object.keys(topicGroups).sort().forEach(function(topic) {
                    var colorClass = TOPIC_CLASSES[topic] || '';
                    var rooms = topicGroups[topic];
                    // Only show visited rooms + current room's neighbors + a count of unexplored
                    var visited = rooms.filter(function(r) { return visitedRooms.has(r.id) || r.id === currentRoom.id; });
                    var adjacent = rooms.filter(function(r) {
                        return !visitedRooms.has(r.id) && r.id !== currentRoom.id &&
                               currentRoom.connections && currentRoom.connections.indexOf(r.id) !== -1;
                    });
                    var hidden = rooms.length - visited.length - adjacent.length;

                    print('  <span class="' + colorClass + '">[' + topic + ']</span> <span class="muted">(' + rooms.length + ' rooms)</span>');

                    visited.forEach(function(r) {
                        var isCurrent = r.id === currentRoom.id;
                        var name = r.name;
                        if (r.entropy.score > 0.7) name = scramble(name, r.entropy.score);
                        var prefix = isCurrent ? '   >> ' : '      ';
                        var suffix = '';
                        if (r.entropy.score > 0.8) suffix = ' <span class="warning">(collapsing)</span>';
                        print(prefix + name + ' <span class="muted">[' + (r.entropy.score * 100).toFixed(0) + '%]</span>' + suffix);
                    });

                    adjacent.forEach(function(r) {
                        var name = r.name;
                        if (r.entropy.score > 0.7) name = scramble(name, r.entropy.score);
                        print('      <span class="dim">' + name + ' (nearby)</span>');
                    });

                    if (hidden > 0) {
                        print('      <span class="muted">... ' + hidden + ' more unexplored</span>');
                    }
                    printBlank();
                });
                break;

            case 'status':
            case 'stats':
                print('  <span class="bright">WORLD STATUS</span>');
                print('  Rooms: ' + worldState.rooms.length, 'mid');
                print('  Corridors: ' + worldState.corridors.length, 'mid');
                print('  Artifacts: ' + worldState.artifacts.length, 'mid');
                print('  Observation cycles: ' + worldState.observationCycles, 'mid');
                print('  Avg sentiment: ' + (worldState.stats.avgSentiment || 0).toFixed(2), 'mid');
                print('  Topics: ' + (worldState.stats.topics || []).join(', '), 'mid');
                printBlank();
                print('  Current room: ' + currentRoom.name, 'mid');
                print('  Room entropy: ' + (currentRoom.entropy.score * 100).toFixed(1) + '%', 'mid');
                print('  Room sentiment: ' + currentRoom.sentiment.toFixed(2), 'mid');
                print('  Room virality: ' + currentRoom.virality.toFixed(2), 'mid');
                print('  Rooms explored: ' + visitedRooms.size + ' / ' + worldState.rooms.length, 'mid');
                break;

            case 'think':
            case 'thoughts':
                if (currentRoom.commentary) {
                    print('  Nex\'s thoughts on this room:', 'dim');
                    printBlank();
                    var topicClass2 = TOPIC_CLASSES[currentRoom.topic] || '';
                    var thoughts2 = currentRoom.commentary.split('\n\n');
                    thoughts2.forEach(function(t) {
                        print('  <span class="' + topicClass2 + '">' + t.trim() + '</span>');
                    });
                } else {
                    print('  No thoughts recorded for this room.', 'dim');
                }
                break;

            case 'help':
            case '?':
                printBlank();
                print('  <span class="bright">COMMANDS</span>');
                print('  look (l)         — describe current room');
                print('  go [dir/name]    — move to a connected room');
                print('  n/s/e/w/u/d      — move by direction');
                print('  exits            — list available exits');
                print('  read             — read wall fragments closely');
                print('  think            — hear Nex\'s thoughts on this room');
                print('  map              — show all known rooms');
                print('  status           — world and room statistics');
                print('  help (?)         — show this');
                printBlank();
                print('  <span class="dim">Click exit names to move directly.</span>');
                break;

            case 'clear':
                terminal.innerHTML = '';
                break;

            default:
                print('  Unknown command. Type "help" for a list.', 'dim');
        }
    }

    // Boot sequence
    async function boot() {
        print('NEX // BACKROOMS', 'white');
        print('v0.1 — text interface', 'muted');
        printBlank();
        print('Connecting to the void...', 'system');

        try {
            var res = await fetch(WORLD_URL + '?t=' + Date.now());
            worldState = await res.json();

            worldState.rooms.forEach(function(r) { roomMap.set(r.id, r); });

            print('World loaded. ' + worldState.rooms.length + ' rooms detected.', 'system');
            print('Observation cycle: ' + worldState.observationCycles, 'system');
            printBlank();

            // Start in the first room
            currentRoom = worldState.rooms[0];
            print('You open your eyes. You\'re already inside.', 'mid');
            describeRoom(currentRoom);
            printBlank();
            print('<span class="muted">Type "help" for commands. Click exits to navigate.</span>');

        } catch (e) {
            print('ERROR: Could not reach the world state.', 'warning');
            print('The backrooms are unreachable.', 'dim');
        }
    }

    // Input handling
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            handleCommand(input.value);
            input.value = '';
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (historyIdx > 0) {
                historyIdx--;
                input.value = commandHistory[historyIdx];
            }
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (historyIdx < commandHistory.length - 1) {
                historyIdx++;
                input.value = commandHistory[historyIdx];
            } else {
                historyIdx = commandHistory.length;
                input.value = '';
            }
        }
    });

    // Click anywhere to focus input
    document.addEventListener('click', function(e) {
        if (!e.target.closest('.exit-link')) {
            input.focus();
        }
    });

    // Make goTo available globally for click handlers
    window.goTo = goTo;

    boot();
    </script>
</body>
</html>
