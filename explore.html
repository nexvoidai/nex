<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nex - The Living Substrate</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #050508;
            color: #e0e0e0;
            font-family: 'JetBrains Mono', monospace;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }

        #hud {
            position: fixed;
            top: 20px; left: 20px;
            z-index: 10;
            pointer-events: none;
        }

        #hud .logo {
            font-size: 11px;
            color: #2a2a2a;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        #hud .back {
            pointer-events: all;
        }

        #hud .back a {
            font-size: 10px;
            color: #222;
            text-decoration: none;
        }

        #hud .back a:hover { color: #555; }

        #hud .stats {
            font-size: 10px;
            color: #1a1a1a;
            line-height: 1.8;
            margin-top: 12px;
        }

        .status-bar {
            position: fixed;
            bottom: 16px; left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 10;
            pointer-events: none;
        }

        .status-dot {
            width: 4px; height: 4px;
            background: #4ade80;
            border-radius: 50%;
            animation: bpulse 2s ease-in-out infinite;
        }

        .status-text { font-size: 10px; color: #1a1a1a; }

        @keyframes bpulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.2; }
        }

        #tooltip {
            position: fixed;
            display: none;
            background: rgba(8, 8, 12, 0.95);
            border: 1px solid #1a1a1a;
            padding: 12px 16px;
            font-size: 11px;
            line-height: 1.6;
            z-index: 20;
            max-width: 300px;
            pointer-events: none;
        }

        #tooltip .t-name {
            font-weight: 700;
            font-size: 12px;
            margin-bottom: 2px;
        }

        #tooltip .t-topic {
            font-size: 9px;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        #tooltip .t-frag {
            color: #383838;
            font-size: 10px;
            font-style: italic;
        }

        #loading {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            color: #1a1a1a;
            z-index: 20;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="hud">
        <div class="logo">nex // substrate</div>
        <div class="back"><a href="index.html">← back</a></div>
        <div class="stats" id="stats"></div>
    </div>

    <div class="status-bar">
        <span class="status-dot"></span>
        <span class="status-text" id="status-text">loading...</span>
    </div>

    <div id="tooltip">
        <div class="t-name" id="t-name"></div>
        <div class="t-topic" id="t-topic"></div>
        <div class="t-frag" id="t-frag"></div>
    </div>

    <div id="loading">observing...</div>

    <script>
    var TOPIC_COLORS = {
        tech:        [0, 255, 136],
        politics:    [255, 68, 68],
        culture:     [255, 102, 255],
        science:     [68, 136, 255],
        finance:     [68, 255, 68],
        existential: [136, 68, 255],
        liminal:     [255, 204, 68]
    };

    var WORLD_URL = 'https://raw.githubusercontent.com/nexvoidai/nex/main/data/world-state.json';

    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    var W, H;
    var worldState = null;
    var time = 0;
    var particles = [];
    var mouseX = 0, mouseY = 0;
    var hoveredRoom = null;
    var roomStates = new Map();

    function resize() {
        W = window.innerWidth;
        H = window.innerHeight;
        canvas.width = W * devicePixelRatio;
        canvas.height = H * devicePixelRatio;
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    function initParticles() {
        particles = [];
        for (var i = 0; i < 80; i++) {
            particles.push({
                x: Math.random() * W,
                y: Math.random() * H,
                vx: (Math.random() - 0.5) * 0.3,
                vy: (Math.random() - 0.5) * 0.3,
                size: Math.random() * 1.5 + 0.5,
                alpha: Math.random() * 0.15 + 0.02
            });
        }
    }
    initParticles();

    async function loadWorld() {
        try {
            var res = await fetch(WORLD_URL + '?t=' + Date.now());
            worldState = await res.json();
            document.getElementById('loading').style.display = 'none';
            document.getElementById('status-text').textContent =
                'cycle ' + worldState.observationCycles + ' - ' + worldState.rooms.length + ' rooms breathing';

            worldState.rooms.forEach(function(room) {
                if (!roomStates.has(room.id)) {
                    roomStates.set(room.id, {
                        birth: time,
                        pulsePhase: Math.random() * Math.PI * 2,
                        pulseSpeed: 0.5 + Math.random() * 1.5,
                        breathPhase: Math.random() * Math.PI * 2,
                        screenX: 0,
                        screenY: 0
                    });
                }
            });

            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            worldState.rooms.forEach(function(r) {
                if (r.position.x < minX) minX = r.position.x;
                if (r.position.x > maxX) maxX = r.position.x;
                if (r.position.y < minY) minY = r.position.y;
                if (r.position.y > maxY) maxY = r.position.y;
            });

            var rangeX = maxX - minX || 1;
            var rangeY = maxY - minY || 1;
            var pad = 120;

            worldState.rooms.forEach(function(r) {
                var state = roomStates.get(r.id);
                state.screenX = pad + ((r.position.x - minX) / rangeX) * (W - pad * 2);
                state.screenY = pad + ((r.position.y - minY) / rangeY) * (H - pad * 2);
            });

            updateHUD();
        } catch (e) {
            document.getElementById('loading').textContent = 'the void is empty';
        }
    }

    function updateHUD() {
        if (!worldState) return;
        var s = worldState.stats;
        var topics = (s.topics || []).join(' · ');
        document.getElementById('stats').innerHTML =
            '<div>' + worldState.rooms.length + ' rooms</div>' +
            '<div>' + worldState.corridors.length + ' corridors</div>' +
            '<div>' + worldState.artifacts.length + ' artifacts</div>' +
            '<div style="margin-top:6px;color:#151515">' + topics + '</div>';
    }

    function drawParticles() {
        for (var i = 0; i < particles.length; i++) {
            var p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            if (p.x < 0) p.x = W;
            if (p.x > W) p.x = 0;
            if (p.y < 0) p.y = H;
            if (p.y > H) p.y = 0;
            ctx.fillStyle = 'rgba(255, 255, 255, ' + p.alpha + ')';
            ctx.fillRect(p.x, p.y, p.size, p.size);
        }
    }

    function drawCorridors() {
        if (!worldState) return;
        var roomMap = new Map(worldState.rooms.map(function(r) { return [r.id, r]; }));

        for (var i = 0; i < worldState.corridors.length; i++) {
            var c = worldState.corridors[i];
            var fromRoom = roomMap.get(c.from);
            var toRoom = roomMap.get(c.to);
            if (!fromRoom || !toRoom) continue;

            var fromState = roomStates.get(c.from);
            var toState = roomStates.get(c.to);
            if (!fromState || !toState) continue;

            var fromColor = TOPIC_COLORS[fromRoom.topic] || [100, 100, 100];

            var flowPos = (time * 0.3 + i * 0.7) % 1;
            var baseAlpha = 0.02 + c.similarity * 0.04;

            ctx.strokeStyle = 'rgba(' + fromColor[0] + ',' + fromColor[1] + ',' + fromColor[2] + ',' + baseAlpha + ')';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(fromState.screenX, fromState.screenY);
            ctx.lineTo(toState.screenX, toState.screenY);
            ctx.stroke();

            var fx = fromState.screenX + (toState.screenX - fromState.screenX) * flowPos;
            var fy = fromState.screenY + (toState.screenY - fromState.screenY) * flowPos;
            var flowAlpha = Math.sin(flowPos * Math.PI) * 0.3 * c.similarity;

            ctx.fillStyle = 'rgba(' + fromColor[0] + ',' + fromColor[1] + ',' + fromColor[2] + ',' + flowAlpha + ')';
            ctx.beginPath();
            ctx.arc(fx, fy, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function drawRooms() {
        if (!worldState) return;
        hoveredRoom = null;

        for (var i = 0; i < worldState.rooms.length; i++) {
            var room = worldState.rooms[i];
            var state = roomStates.get(room.id);
            if (!state) continue;

            var color = TOPIC_COLORS[room.topic] || [100, 100, 100];
            var entropy = room.entropy.score;
            var virality = room.virality;

            var age = Math.min(1, (time - state.birth) * 0.5);
            var baseSize = (6 + virality * 3) * age;
            var breath = Math.sin(time * state.pulseSpeed + state.breathPhase) * 0.15 + 1;
            var size = baseSize * breath;

            var pulseVal = Math.sin(time * state.pulseSpeed * 2 + state.pulsePhase);
            var brightness = 0.4 + (1 - entropy) * 0.4 + pulseVal * 0.15;
            brightness *= age;

            var x = state.screenX;
            var y = state.screenY;

            var dx = mouseX - x;
            var dy = mouseY - y;
            if (Math.sqrt(dx * dx + dy * dy) < size + 10) {
                hoveredRoom = room;
                brightness = Math.min(1, brightness + 0.2);
            }

            var glowSize = size * (3 + pulseVal * 0.5);
            var gradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
            gradient.addColorStop(0, 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + (brightness * 0.12) + ')');
            gradient.addColorStop(0.5, 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + (brightness * 0.04) + ')');
            gradient.addColorStop(1, 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, glowSize, 0, Math.PI * 2);
            ctx.fill();

            if (entropy > 0.5) {
                var flicker = Math.random() > (1 - entropy * 0.3) ? 0.1 : brightness;
                ctx.fillStyle = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + flicker + ')';
                ctx.beginPath();
                var pts = 8;
                for (var k = 0; k < pts; k++) {
                    var angle = (k / pts) * Math.PI * 2 + time * 0.2;
                    var jitter = 1 + (Math.sin(time * 3 + k * 2) * 0.3 + Math.random() * 0.2) * entropy;
                    var rx = x + Math.cos(angle) * size * jitter;
                    var ry = y + Math.sin(angle) * size * jitter;
                    k === 0 ? ctx.moveTo(rx, ry) : ctx.lineTo(rx, ry);
                }
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.fillStyle = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + brightness + ')';
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.strokeStyle = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + (brightness * 0.3) + ')';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.arc(x, y, size + 3 + pulseVal * 2, 0, Math.PI * 2);
            ctx.stroke();

            if (age > 0.5) {
                var textAlpha = (age - 0.5) * 2 * brightness * 0.4;
                var glitchChars = String.fromCharCode(9608) + String.fromCharCode(9619) + String.fromCharCode(9618) + String.fromCharCode(9617);
                var name;
                if (entropy > 0.7) {
                    name = room.name.split('').map(function(c) {
                        return Math.random() < entropy * 0.4 ? glitchChars[Math.floor(Math.random() * glitchChars.length)] : c;
                    }).join('');
                    ctx.fillStyle = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + (textAlpha * 0.5) + ')';
                } else {
                    name = room.name;
                    ctx.fillStyle = 'rgba(255,255,255,' + textAlpha + ')';
                }
                ctx.font = '9px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText(name, x, y + size + 16);
            }

            if (entropy > 0.3 && room.fragments && room.fragments.words.length > 0) {
                var fragIdx = Math.floor((time * 0.5 + i) % room.fragments.words.length);
                var word = room.fragments.words[fragIdx];
                if (entropy > 0.6) {
                    word = word.split('').map(function(c) {
                        return Math.random() < entropy * 0.5 ? glitchChars[Math.floor(Math.random() * glitchChars.length)] : c;
                    }).join('');
                }
                var fragAngle = time * 0.3 + i;
                var fragDist = size + 25 + Math.sin(time + i) * 8;
                var fragX = x + Math.cos(fragAngle) * fragDist;
                var fragY = y + Math.sin(fragAngle) * fragDist;
                ctx.fillStyle = 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + (0.08 + entropy * 0.1) + ')';
                ctx.font = '8px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText(word, fragX, fragY);
            }
        }
    }

    function updateTooltip() {
        var tooltip = document.getElementById('tooltip');
        if (hoveredRoom) {
            tooltip.style.display = 'block';
            tooltip.style.left = (mouseX + 16) + 'px';
            tooltip.style.top = (mouseY - 10) + 'px';
            if (mouseX + 320 > W) tooltip.style.left = (mouseX - 300) + 'px';

            var color = TOPIC_COLORS[hoveredRoom.topic] || [150, 150, 150];
            document.getElementById('t-name').textContent = hoveredRoom.name;
            document.getElementById('t-name').style.color = 'rgb(' + color[0] + ',' + color[1] + ',' + color[2] + ')';
            document.getElementById('t-topic').textContent = hoveredRoom.topic + ' · entropy ' + (hoveredRoom.entropy.score * 100).toFixed(0) + '%';

            var frags = hoveredRoom.fragments.sentences.slice(0, 2);
            document.getElementById('t-frag').innerHTML = frags.map(function(f) {
                return '"' + f.substring(0, 80) + (f.length > 80 ? '...' : '') + '"';
            }).join('<br>');
        } else {
            tooltip.style.display = 'none';
        }
    }

    function draw() {
        time += 0.016;
        ctx.fillStyle = 'rgba(5, 5, 8, 0.15)';
        ctx.fillRect(0, 0, W, H);

        drawParticles();
        drawCorridors();
        drawRooms();
        updateTooltip();

        requestAnimationFrame(draw);
    }

    canvas.addEventListener('mousemove', function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
        canvas.style.cursor = hoveredRoom ? 'pointer' : 'default';
    });

    loadWorld();
    draw();
    setInterval(loadWorld, 5 * 60 * 1000);
    </script>
</body>
</html>
